#Requires -Version 7.5
<#
.SYNOPSIS
    Load Bus Buddy PowerShell Environment Profiles
.DESCRIPTION
    Loads the main Bus Buddy PowerShell module (5,434 lines) and associated AI integration modules
    as specified in the BusBuddy project instructions.
.PARAMETER Quiet
    Suppress verbose output during loading
.EXAMPLE
    .\load-bus-buddy-profiles.ps1
.EXAMPLE
    .\load-bus-buddy-profiles.ps1 -Quiet
#>

[CmdletBinding()]
param(
    [switch]$Quiet,
    [switch]$InstallMissingDependencies,
    [switch]$SkipOptionalModules
)

# Enhanced error handling and logging
$ErrorActionPreference = 'Stop'
$ProgressPreference = 'SilentlyContinue'

# Define paths
$WorkspaceRoot = $PSScriptRoot
$PowerShellDir = Join-Path $WorkspaceRoot "PowerShell"
$BusBuddyEnvironmentDir = Join-Path $PowerShellDir "BusBuddy PowerShell Environment"
$ModulesDir = Join-Path $BusBuddyEnvironmentDir "Modules"
$MainModulePath = Join-Path $ModulesDir "BusBuddy\BusBuddy.psm1"
$AIModulePath = Join-Path $ModulesDir "BusBuddy.AI"

function Write-LoadStatus {
    param([string]$Message, [string]$Color = 'White')
    if (-not $Quiet) {
        Write-Host $Message -ForegroundColor $Color
    }
}

function Test-PowerShell752 {
    if ($PSVersionTable.PSVersion.Major -lt 7 -or
        ($PSVersionTable.PSVersion.Major -eq 7 -and $PSVersionTable.PSVersion.Minor -lt 5)) {
        throw "PowerShell 7.5+ required. Current version: $($PSVersionTable.PSVersion)"
    }
}

function Import-BusBuddyModule {
    param([string]$ModulePath, [string]$ModuleName, [switch]$SkipDependencies)

    if (-not (Test-Path $ModulePath)) {
        throw "Module not found: $ModulePath"
    }

    try {
        Write-LoadStatus "üì¶ Loading $ModuleName..." -Color 'Cyan'

        # Check for missing dependencies before loading
        if (-not $SkipDependencies -and $ModulePath -like "*BusBuddy.AI*") {
            $MissingDeps = Test-ModuleDependencies -ModulePath $ModulePath
            if ($MissingDeps.Count -gt 0) {
                Write-LoadStatus "‚ö†Ô∏è Missing dependencies for $ModuleName`: $($MissingDeps -join ', ')" -Color 'Yellow'
                Write-LoadStatus "   Install with: Install-Module $($MissingDeps -join ', ') -Scope CurrentUser" -Color 'Gray'
                return $false
            }
        }

        Import-Module $ModulePath -Force -Scope Global
        Write-LoadStatus "‚úÖ $ModuleName loaded successfully" -Color 'Green'
        return $true
    }
    catch {
        # Enhanced error analysis
        $ErrorDetails = Get-ModuleErrorAnalysis -Exception $_.Exception -ModuleName $ModuleName
        Write-LoadStatus "‚ùå Failed to load $ModuleName`: $($ErrorDetails.Summary)" -Color 'Red'

        if ($ErrorDetails.Suggestion) {
            Write-LoadStatus "   üí° Suggestion: $($ErrorDetails.Suggestion)" -Color 'Yellow'
        }

        return $false
    }
}

function Test-ModuleDependencies {
    param([string]$ModulePath)

    $MissingModules = @()

    try {
        # Parse module manifest for required modules
        $ManifestPath = $ModulePath -replace '\.psm1$', '.psd1'
        if (Test-Path $ManifestPath) {
            $Manifest = Import-PowerShellDataFile $ManifestPath
            if ($Manifest.RequiredModules) {
                foreach ($RequiredModule in $Manifest.RequiredModules) {
                    $ModuleName = if ($RequiredModule -is [string]) { $RequiredModule } else { $RequiredModule.ModuleName }
                    if (-not (Get-Module $ModuleName -ListAvailable -ErrorAction SilentlyContinue)) {
                        $MissingModules += $ModuleName
                    }
                }
            }
        }
    }
    catch {
        Write-LoadStatus "   ‚ö†Ô∏è Could not check dependencies: $_" -Color 'Gray'
    }

    return $MissingModules
}

function Get-ModuleErrorAnalysis {
    param([System.Exception]$Exception, [string]$ModuleName)

    $ErrorDetails = @{
        Summary = $Exception.Message
        Suggestion = $null
        ErrorType = 'Unknown'
        QuickFix = $null
        Priority = 'Medium'
    }

    # Analyze common error patterns with enhanced classification
    if ($Exception.Message -like "*required module*not loaded*") {
        $ErrorDetails.ErrorType = 'MissingDependency'
        $ErrorDetails.Suggestion = "Install missing dependencies or use -SkipOptionalModules"
        $ErrorDetails.QuickFix = "AI features have been removed from BusBuddy for simplified operation"
        $ErrorDetails.Priority = 'Low'
    }
    elseif ($Exception.Message -like "*execution policy*") {
        $ErrorDetails.ErrorType = 'ExecutionPolicy'
        $ErrorDetails.Suggestion = "Run: Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser"
        $ErrorDetails.QuickFix = "Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser"
        $ErrorDetails.Priority = 'High'
    }
    elseif ($Exception.Message -like "*access*denied*") {
        $ErrorDetails.ErrorType = 'PermissionDenied'
        $ErrorDetails.Suggestion = "Run PowerShell as Administrator or check file permissions"
        $ErrorDetails.QuickFix = "Start-Process pwsh -Verb RunAs"
        $ErrorDetails.Priority = 'High'
    }
    elseif ($Exception.Message -like "*version*") {
        $ErrorDetails.ErrorType = 'VersionMismatch'
        $ErrorDetails.Suggestion = "Check PowerShell version compatibility"
        $ErrorDetails.QuickFix = "Update PowerShell to 7.5.2+"
        $ErrorDetails.Priority = 'Critical'
    }
    elseif ($Exception.Message -like "*duplicate*member*" -or $Exception.Message -like "*already*contains*definition*") {
        $ErrorDetails.ErrorType = 'DuplicateDefinition'
        $ErrorDetails.Suggestion = "Remove duplicate class/method definitions"
        $ErrorDetails.QuickFix = "Find and remove duplicate code in project files"
        $ErrorDetails.Priority = 'Critical'
    }
    elseif ($Exception.Message -like "*build*failed*" -or $Exception.Message -like "*compilation*error*") {
        $ErrorDetails.ErrorType = 'BuildError'
        $ErrorDetails.Suggestion = "Check compilation errors and fix code issues"
        $ErrorDetails.QuickFix = "Review build output for specific error details"
        $ErrorDetails.Priority = 'Critical'
    }
    else {
        $ErrorDetails.Suggestion = "Check module integrity and dependencies"
        $ErrorDetails.QuickFix = "Restart PowerShell session and reload modules"
        $ErrorDetails.Priority = 'Medium'
    }

    return $ErrorDetails
}

function Get-CriticalExitCodeAnalysis {
    param([int]$ExitCode)

    $ExitCodeDetails = @{
        Code = $ExitCode
        Type = 'Unknown'
        Severity = 'Medium'
        Suggestion = 'Check logs for details'
        QuickFix = 'Restart process'
    }

    switch ($ExitCode) {
        -532462766 {
            $ExitCodeDetails.Type = 'PowerShellCorruption'
            $ExitCodeDetails.Severity = 'Critical'
            $ExitCodeDetails.Suggestion = 'PowerShell script syntax error or corrupted module'
            $ExitCodeDetails.QuickFix = 'Check script syntax and reload modules'
        }
        -1073741819 {
            $ExitCodeDetails.Type = 'AccessViolation'
            $ExitCodeDetails.Severity = 'Critical'
            $ExitCodeDetails.Suggestion = 'Memory access violation - possible corrupted assembly'
            $ExitCodeDetails.QuickFix = 'Restart application and check for corrupted files'
        }
        -1073741515 {
            $ExitCodeDetails.Type = 'DependencyMissing'
            $ExitCodeDetails.Severity = 'High'
            $ExitCodeDetails.Suggestion = 'Missing dependency or DLL not found'
            $ExitCodeDetails.QuickFix = 'Check and restore missing dependencies'
        }
        1 {
            $ExitCodeDetails.Type = 'GeneralError'
            $ExitCodeDetails.Severity = 'Medium'
            $ExitCodeDetails.Suggestion = 'General application error'
            $ExitCodeDetails.QuickFix = 'Check error logs and retry'
        }
        default {
            if ($ExitCode -lt 0) {
                $ExitCodeDetails.Type = 'SystemError'
                $ExitCodeDetails.Severity = 'High'
                $ExitCodeDetails.Suggestion = 'System-level error occurred'
                $ExitCodeDetails.QuickFix = 'Check system logs and restart'
            }
        }
    }

    return $ExitCodeDetails
}

function Invoke-BuildErrorCapture {
    param(
        [string]$BuildCommand = "dotnet build BusBuddy.sln",
        [switch]$ParseErrors,
        [switch]$SuggestFixes
    )

    Write-LoadStatus "üîç Capturing build output with enhanced error detection..." -Color 'Cyan'

    try {
        # Simple approach to avoid threading issues
        Write-LoadStatus "üî® Executing: $BuildCommand" -Color 'Gray'

        $TempOutputFile = [System.IO.Path]::GetTempFileName()
        $TempErrorFile = [System.IO.Path]::GetTempFileName()

        $ProcessParams = @{
            FilePath = 'pwsh'
            ArgumentList = @('-Command', $BuildCommand)
            RedirectStandardOutput = $TempOutputFile
            RedirectStandardError = $TempErrorFile
            Wait = $true
            PassThru = $true
            NoNewWindow = $true
        }

        $Process = Start-Process @ProcessParams

        # Read captured output
        $StandardOutput = if (Test-Path $TempOutputFile) { Get-Content $TempOutputFile } else { @() }
        $StandardError = if (Test-Path $TempErrorFile) { Get-Content $TempErrorFile } else { @() }

        # Clean up temp files
        Remove-Item $TempOutputFile -ErrorAction SilentlyContinue
        Remove-Item $TempErrorFile -ErrorAction SilentlyContinue

        $AllOutput = @($StandardOutput) + @($StandardError)

        # Analyze exit code
        $ExitCodeAnalysis = Get-CriticalExitCodeAnalysis -ExitCode $Process.ExitCode

        Write-LoadStatus "üìä Process completed with exit code: $($Process.ExitCode)" -Color $(if($Process.ExitCode -eq 0){'Green'}else{'Red'})

        if ($Process.ExitCode -ne 0) {
            Write-LoadStatus "‚ö†Ô∏è Exit Code Analysis:" -Color 'Yellow'
            Write-LoadStatus "   Type: $($ExitCodeAnalysis.Type)" -Color 'White'
            Write-LoadStatus "   Severity: $($ExitCodeAnalysis.Severity)" -Color $(if($ExitCodeAnalysis.Severity -eq 'Critical'){'Red'}elseif($ExitCodeAnalysis.Severity -eq 'High'){'Yellow'}else{'White'})
            Write-LoadStatus "   Suggestion: $($ExitCodeAnalysis.Suggestion)" -Color 'Cyan'
            Write-LoadStatus "   Quick Fix: $($ExitCodeAnalysis.QuickFix)" -Color 'Green'
        }

        if ($ParseErrors -and $AllOutput.Count -gt 0) {
            $ParsedErrors = Get-BuildErrorAnalysis -BuildOutput $AllOutput

            Write-LoadStatus "üîç Error Analysis Results:" -Color 'Cyan'
            Write-LoadStatus "   Total Errors: $($ParsedErrors.TotalErrors)" -Color $(if($ParsedErrors.TotalErrors -gt 0){'Red'}else{'Green'})
            Write-LoadStatus "   Total Warnings: $($ParsedErrors.TotalWarnings)" -Color $(if($ParsedErrors.TotalWarnings -gt 0){'Yellow'}else{'Green'})
            Write-LoadStatus "   Critical Issues: $($ParsedErrors.CriticalIssues.Count)" -Color $(if($ParsedErrors.CriticalIssues.Count -gt 0){'Magenta'}else{'Green'})

            return @{
                ExitCode = $Process.ExitCode
                Output = $AllOutput
                ParsedErrors = $ParsedErrors
                ExitCodeAnalysis = $ExitCodeAnalysis
                Success = $Process.ExitCode -eq 0
                CriticalFailure = $ExitCodeAnalysis.Severity -eq 'Critical'
            }
        }

        return @{
            ExitCode = $Process.ExitCode
            Output = $AllOutput
            ExitCodeAnalysis = $ExitCodeAnalysis
            Success = $Process.ExitCode -eq 0
            CriticalFailure = $ExitCodeAnalysis.Severity -eq 'Critical'
        }
    }
    catch {
        Write-LoadStatus "‚ùå Failed to capture build output: $_" -Color 'Red'
        return @{
            ExitCode = -1
            Output = @("Error capturing build output: $_")
            Success = $false
            CriticalFailure = $true
            Exception = $_
        }
    }
}

function Get-BuildErrorAnalysis {
    param([array]$BuildOutput)

    $Errors = @()
    $Warnings = @()
    $CriticalIssues = @()

    Write-LoadStatus "üîç Parsing $($BuildOutput.Count) lines of build output..." -Color 'Gray'

    foreach ($Line in $BuildOutput) {
        # Enhanced error pattern matching for C#, XAML, Syncfusion, and PowerShell
        if ($Line -match "error\s+(\w+\d+):\s*(.+?)\s+\[(.+?)\]" -or
            $Line -match "(.+?)\(\d+,\d+\):\s*error\s+(\w+\d+):\s*(.+)" -or
            $Line -match "error\s+(\w+\d+):\s*(.+)" -or
            $Line -match "Build FAILED" -or
            $Line -match "compilation failed") {

            $ErrorCode = $Matches[2] ?? $Matches[1] ?? "UNKNOWN"
            $ErrorMessage = $Matches[3] ?? $Matches[2] ?? $Line
            $ErrorFile = $Matches[1] ?? $Matches[3] ?? "Unknown"

            $ErrorInfo = @{
                Type = 'CompilationError'
                Code = $ErrorCode
                Message = $ErrorMessage
                File = $ErrorFile
                Line = $Line
                Priority = 'Critical'
                QuickFix = Get-ErrorQuickFix -ErrorCode $ErrorCode -ErrorMessage $ErrorMessage
            }

            $Errors += $ErrorInfo

            # Identify critical issues by error code
            if ($ErrorCode -in @('CS0111', 'CS0102', 'CS0017', 'CS0246', 'CS0103', 'CS1061', 'CS0234')) {
                $CriticalIssues += $ErrorInfo
            }

            Write-LoadStatus "   Found Error: $ErrorCode - $ErrorMessage" -Color 'Red'
        }
        # XAML-specific error patterns
        elseif ($Line -match "XamlParseException|XamlObjectWriterException" -or
                $Line -match "MC\d+:" -or
                $Line -match "XAML.*error" -or
                $Line -match "markup.*error") {

            $XamlErrorCode = if ($Line -match "MC(\d+)") { "MC$($Matches[1])" } else { "XamlParseException" }
            $XamlMessage = $Line.Trim()

            $ErrorInfo = @{
                Type = 'XamlError'
                Code = $XamlErrorCode
                Message = $XamlMessage
                File = "XAML File"
                Line = $Line
                Priority = 'High'
                QuickFix = Get-ErrorQuickFix -ErrorCode $XamlErrorCode -ErrorMessage $XamlMessage
            }

            $Errors += $ErrorInfo
            $CriticalIssues += $ErrorInfo

            Write-LoadStatus "   Found XAML Error: $XamlErrorCode - $XamlMessage" -Color 'Magenta'
        }
        # Syncfusion-specific error patterns
        elseif ($Line -match "Syncfusion.*license" -or
                $Line -match "Syncfusion.*not found" -or
                $Line -match "Syncfusion.*namespace" -or
                $Line -match "Syncfusion.*theme" -or
                $Line -match "xmlns.*syncfusion") {

            $SyncfusionCode = "SYNCFUSION"
            $SyncfusionMessage = $Line.Trim()

            $ErrorInfo = @{
                Type = 'SyncfusionError'
                Code = $SyncfusionCode
                Message = $SyncfusionMessage
                File = "Syncfusion Integration"
                Line = $Line
                Priority = 'High'
                QuickFix = Get-ErrorQuickFix -ErrorCode $SyncfusionCode -ErrorMessage $SyncfusionMessage
            }

            $Errors += $ErrorInfo

            Write-LoadStatus "   Found Syncfusion Error: $SyncfusionMessage" -Color 'Blue'
        }
        # PowerShell parsing and runtime errors
        elseif ($Line -match "PowerShell.*error" -or
                $Line -match "ParserError" -or
                $Line -match "RuntimeException" -or
                $Line -match "ParameterBindingException" -or
                $Line -match "CommandNotFoundException" -or
                $Line -match "At line:\d+" -or
                $Line -match "CategoryInfo.*PowerShell") {

            $PSErrorCode = "POWERSHELL_PARSE"
            if ($Line -match "ParameterBinding") { $PSErrorCode = "PS002" }
            elseif ($Line -match "CommandNotFound") { $PSErrorCode = "PS003" }
            elseif ($Line -match "ExecutionPolicy") { $PSErrorCode = "PS004" }
            elseif ($Line -match "ModuleNotFound") { $PSErrorCode = "PS005" }

            $PSMessage = $Line.Trim()

            $ErrorInfo = @{
                Type = 'PowerShellError'
                Code = $PSErrorCode
                Message = $PSMessage
                File = "PowerShell Script"
                Line = $Line
                Priority = 'Medium'
                QuickFix = Get-ErrorQuickFix -ErrorCode $PSErrorCode -ErrorMessage $PSMessage
            }

            $Errors += $ErrorInfo

            Write-LoadStatus "   Found PowerShell Error: $PSErrorCode - $PSMessage" -Color 'Cyan'
        }
        # MSBuild and project system errors
        elseif ($Line -match "MSB\d+:" -or
                $Line -match "error.*MSBuild" -or
                $Line -match "project.*error" -or
                $Line -match "target.*failed") {

            $MSBuildCode = if ($Line -match "MSB(\d+)") { "MSB$($Matches[1])" } else { "MSB_GENERAL" }
            $MSBuildMessage = $Line.Trim()

            $ErrorInfo = @{
                Type = 'MSBuildError'
                Code = $MSBuildCode
                Message = $MSBuildMessage
                File = "Project System"
                Line = $Line
                Priority = 'High'
                QuickFix = Get-ErrorQuickFix -ErrorCode $MSBuildCode -ErrorMessage $MSBuildMessage
            }

            $Errors += $ErrorInfo
            if ($MSBuildCode -in @('MSB3026', 'MSB3027', 'MSB3021')) {
                $CriticalIssues += $ErrorInfo
            }

            Write-LoadStatus "   Found MSBuild Error: $MSBuildCode - $MSBuildMessage" -Color 'DarkYellow'
        }
        # NuGet package errors
        elseif ($Line -match "NU\d+:" -or
                $Line -match "package.*error" -or
                $Line -match "NuGet.*error") {

            $NuGetCode = if ($Line -match "NU(\d+)") { "NU$($Matches[1])" } else { "NUGET_GENERAL" }
            $NuGetMessage = $Line.Trim()

            $ErrorInfo = @{
                Type = 'NuGetError'
                Code = $NuGetCode
                Message = $NuGetMessage
                File = "Package Management"
                Line = $Line
                Priority = 'Medium'
                QuickFix = Get-ErrorQuickFix -ErrorCode $NuGetCode -ErrorMessage $NuGetMessage
            }

            $Errors += $ErrorInfo

            Write-LoadStatus "   Found NuGet Error: $NuGetCode - $NuGetMessage" -Color 'DarkGreen'
        }
        # Resource and namespace errors
        elseif ($Line -match "resource.*not found" -or
                $Line -match "namespace.*not found" -or
                $Line -match "assembly.*not found" -or
                $Line -match "type.*not found") {

            $ResourceCode = "RESOURCE_NOT_FOUND"
            if ($Line -match "namespace") { $ResourceCode = "NAMESPACE_NOT_FOUND" }
            elseif ($Line -match "assembly") { $ResourceCode = "ASSEMBLY_NOT_FOUND" }
            elseif ($Line -match "type") { $ResourceCode = "TYPE_NOT_FOUND" }

            $ResourceMessage = $Line.Trim()

            $ErrorInfo = @{
                Type = 'ResourceError'
                Code = $ResourceCode
                Message = $ResourceMessage
                File = "Resource System"
                Line = $Line
                Priority = 'High'
                QuickFix = Get-ErrorQuickFix -ErrorCode $ResourceCode -ErrorMessage $ResourceMessage
            }

            $Errors += $ErrorInfo
            $CriticalIssues += $ErrorInfo

            Write-LoadStatus "   Found Resource Error: $ResourceCode - $ResourceMessage" -Color 'DarkMagenta'
        }
        # Warning patterns (enhanced)
        elseif ($Line -match "warning\s+(\w+\d+):\s*(.+)" -or
                $Line -match "(.+?)\(\d+,\d+\):\s*warning\s+(\w+\d+):\s*(.+)" -or
                $Line -match "Warning.*:" -or
                $Line -match "WARN:") {

            $WarningCode = $Matches[1] ?? $Matches[2] ?? "WARNING"
            $WarningMessage = $Matches[2] ?? $Matches[3] ?? $Line.Trim()

            $Warnings += @{
                Type = 'Warning'
                Code = $WarningCode
                Message = $WarningMessage
                Line = $Line
                Priority = 'Low'
            }

            Write-LoadStatus "   Found Warning: $WarningCode - $WarningMessage" -Color 'Yellow'
        }
        # Check for build failure indicators even without specific error codes
        elseif ($Line -match "Build FAILED" -or
                ($Line -match "failed|FAILED" -and $Line -match "error") -or
                $Line -match "FAIL:" -or
                $Line -match "Exception.*:" -and -not ($Line -match "warning")) {

            $FailureMessage = $Line.Trim()

            $Errors += @{
                Type = 'BuildFailure'
                Code = 'BUILDFAIL'
                Message = $FailureMessage
                File = "Build System"
                Line = $Line
                Priority = 'Critical'
                QuickFix = "Check detailed build output for specific errors"
            }

            Write-LoadStatus "   Found Build Failure: $FailureMessage" -Color 'Red'
        }
    }

    Write-LoadStatus "üîç Parsing complete: $($Errors.Count) errors, $($Warnings.Count) warnings found" -Color 'Gray'

    return @{
        Errors = $Errors
        Warnings = $Warnings
        CriticalIssues = $CriticalIssues
        TotalErrors = $Errors.Count
        TotalWarnings = $Warnings.Count
        HasCriticalIssues = $CriticalIssues.Count -gt 0
    }
}

function Get-ErrorQuickFix {
    param([string]$ErrorCode, [string]$ErrorMessage)

    switch ($ErrorCode) {
        # C# Compilation Errors
        'CS0111' { return "Remove duplicate method definition" }
        'CS0102' { return "Remove duplicate class/type definition" }
        'CS0017' { return "Remove duplicate using directive" }
        'CS0246' { return "Add missing using directive or assembly reference" }
        'CS0103' { return "Declare the variable or add missing using directive" }
        'CS0234' { return "Add missing namespace reference or check spelling" }
        'CS0029' { return "Cannot implicitly convert type - add explicit cast or change types" }
        'CS1061' { return "Type does not contain definition - check method/property name and using directives" }
        'CS0019' { return "Operator cannot be applied to operands - check data types" }
        'CS0161' { return "Method must return a value - add return statement" }
        'CS0120' { return "Non-static member requires object reference - make static or create instance" }
        'CS0128' { return "Local variable already defined - use different name or remove duplicate" }
        'CS0165' { return "Use of unassigned local variable - initialize before use" }
        'CS0266' { return "Cannot implicitly convert - add explicit cast" }
        'CS0428' { return "Cannot convert method group to non-delegate type - add parentheses for method call" }
        'CS1503' { return "Argument type mismatch - check parameter types" }
        'CS0115' { return "No suitable method found to override - check method signature" }
        'CS0101' { return "Namespace already contains definition - rename or remove duplicate" }
        'CS0117' { return "Type does not contain definition - check static member name" }
        'CS0122' { return "Member is inaccessible due to protection level - change accessibility" }
        'CS0133' { return "Expression assigned is not constant - use const-compatible value" }
        'CS0136' { return "Local variable hides member - rename local variable" }
        'CS0201' { return "Only assignment, call, increment, decrement expressions can be used as statement" }
        'CS0229' { return "Ambiguity between members - use explicit qualification" }
        'CS0400' { return "Type or namespace name could not be found in global namespace" }
        'CS0507' { return "Cannot change access modifiers when overriding - match base class accessibility" }
        'CS0508' { return "Return type must match overridden member" }
        'CS0534' { return "Class does not implement inherited abstract member - implement required members" }
        'CS0535' { return "Class does not implement interface member - implement required interface" }
        'CS1519' { return "Invalid token - check syntax near error location" }
        'CS1525' { return "Invalid expression term - check expression syntax" }
        'CS1002' { return "Syntax error, expected token - check semicolons and braces" }
        'CS1513' { return "Expected closing brace - check brace matching" }
        'CS1514' { return "Expected opening brace - add missing opening brace" }
        'CS1520' { return "Method must have return type - add void or specific return type" }

        # XAML-specific Errors
        'XamlParseException' { return "XAML syntax error - check element syntax and namespaces" }
        'XamlObjectWriterException' { return "XAML object creation failed - check constructor and property values" }
        'MC3000' { return "Unknown XML element - check element name and namespace declarations" }
        'MC3001' { return "Unknown XML attribute - check attribute name and namespace" }
        'MC6017' { return "Attribute value must be a string - remove markup extensions from string attributes" }
        'MC1000' { return "Unknown build action - check file properties in project" }
        'MC3005' { return "Type not found - add assembly reference or check namespace" }
        'MC3072' { return "Property does not exist - check property name and type" }
        'MC4006' { return "Malformed element - check element syntax" }
        'MC3003' { return "Cannot set property - property may be read-only or type mismatch" }
        'MC9998' { return "Internal XAML compiler error - clean and rebuild project" }

        # Syncfusion-specific Errors
        'SF001' { return "Syncfusion license not found - register license key in App.xaml.cs" }
        'SF002' { return "Invalid Syncfusion control usage - check control documentation" }
        'SF003' { return "Syncfusion assembly version mismatch - ensure consistent versions" }
        'SF004' { return "Missing Syncfusion namespace - add xmlns:syncfusion declaration" }
        'SF005' { return "Syncfusion theme not applied - check theme resource dictionary inclusion" }
        'SYNCFUSION' {
            if ($ErrorMessage -like "*license*") {
                return "Add Syncfusion.Licensing.SyncfusionLicenseProvider.RegisterLicense() in App constructor"
            }
            elseif ($ErrorMessage -like "*namespace*" -or $ErrorMessage -like "*xmlns*") {
                return "Add xmlns:syncfusion='http://schemas.syncfusion.com/wpf' to XAML root element"
            }
            elseif ($ErrorMessage -like "*theme*" -or $ErrorMessage -like "*style*") {
                return "Add Syncfusion theme resource dictionary to App.xaml or control resources"
            }
            else {
                return "Check Syncfusion documentation for control-specific requirements"
            }
        }

        # Resource and Reference Errors
        'RESOURCE_NOT_FOUND' { return "Add missing resource to project or check resource path" }
        'ASSEMBLY_NOT_FOUND' { return "Add missing assembly reference via NuGet or project reference" }
        'NAMESPACE_NOT_FOUND' { return "Add using directive or assembly reference for namespace" }
        'TYPE_NOT_FOUND' { return "Check type name spelling and add necessary using directives" }

        # PowerShell-specific Errors
        'PS001' { return "PowerShell syntax error - check script syntax and formatting" }
        'PS002' { return "Parameter binding failed - check parameter names and types" }
        'PS003' { return "Command not found - check command name and module import" }
        'PS004' { return "Execution policy restriction - run Set-ExecutionPolicy RemoteSigned" }
        'PS005' { return "Module not found - install module or check module path" }
        'POWERSHELL_PARSE' { return "PowerShell parsing error - validate script syntax" }
        'POWERSHELL_RUNTIME' { return "PowerShell runtime error - check variable initialization and logic" }

        # MSBuild and Project Errors
        'MSB3026' { return "Could not copy file - check file permissions and locks" }
        'MSB3027' { return "Could not copy file due to lock - close applications using the file" }
        'MSB3021' { return "Unable to copy file - file may be in use by another process" }
        'MSB3075' { return "Directory not found - create missing directory or fix path" }
        'MSB3103' { return "Invalid project file - check XML syntax and structure" }
        'MSB3202' { return "Project file could not be loaded - check file corruption" }
        'MSB4018' { return "Task failed unexpectedly - check task parameters and dependencies" }
        'MSB4019' { return "Imported project not found - check project reference path" }
        'MSB4062' { return "Task could not be loaded - check task assembly reference" }

        # NuGet Package Errors
        'NU1001' { return "Unknown project type - check project file format" }
        'NU1101' { return "Package not found - check package source and name" }
        'NU1102' { return "Package version not found - check available versions" }
        'NU1103' { return "Package dependency could not be resolved - check dependency tree" }
        'NU1201' { return "Project is not compatible with target framework - check framework version" }
        'NU1202' { return "Package is not compatible with target framework - update package or framework" }
        'NU1605' { return "Package downgrade detected - resolve version conflicts" }

        # Generic Patterns
        default {
            # Analyze error message for common patterns
            if ($ErrorMessage -like "*namespace*" -and $ErrorMessage -like "*not found*") {
                return "Add missing using directive or assembly reference"
            }
            elseif ($ErrorMessage -like "*license*" -and $ErrorMessage -like "*syncfusion*") {
                return "Register Syncfusion license key in App.xaml.cs constructor"
            }
            elseif ($ErrorMessage -like "*xmlns*" -or $ErrorMessage -like "*namespace declaration*") {
                return "Add missing XML namespace declaration to XAML file"
            }
            elseif ($ErrorMessage -like "*resource*" -and $ErrorMessage -like "*not found*") {
                return "Add missing resource file to project or check resource path"
            }
            elseif ($ErrorMessage -like "*assembly*" -and $ErrorMessage -like "*not found*") {
                return "Add missing assembly reference via NuGet package manager"
            }
            elseif ($ErrorMessage -like "*syntax*" -or $ErrorMessage -like "*parse*") {
                return "Check syntax and formatting near the error location"
            }
            elseif ($ErrorMessage -like "*duplicate*") {
                return "Remove duplicate definitions or rename conflicting items"
            }
            elseif ($ErrorMessage -like "*access*" -and $ErrorMessage -like "*denied*") {
                return "Check file permissions or run with elevated privileges"
            }
            elseif ($ErrorMessage -like "*version*" -and $ErrorMessage -like "*mismatch*") {
                return "Ensure consistent package versions across all projects"
            }
            else {
                return "Review error message and fix accordingly"
            }
        }
    }
}function Test-BusBuddyCommands {
    $ExpectedCommands = @('bb-health', 'bb-build', 'bb-run', 'bb-diagnostic', 'bb-dev-session')
    $LoadedCommands = @()

    foreach ($Command in $ExpectedCommands) {
        if (Get-Command $Command -ErrorAction SilentlyContinue) {
            $LoadedCommands += $Command
        }
    }

    Write-LoadStatus "üéØ BusBuddy Commands Available: $($LoadedCommands.Count)/$($ExpectedCommands.Count)" -Color 'Yellow'

    if ($LoadedCommands.Count -gt 0) {
        Write-LoadStatus "   Available: $($LoadedCommands -join ', ')" -Color 'Green'
    }

    $MissingCommands = $ExpectedCommands | Where-Object { $_ -notin $LoadedCommands }
    if ($MissingCommands.Count -gt 0) {
        Write-LoadStatus "   Missing: $($MissingCommands -join ', ')" -Color 'Red'
    }

    return $LoadedCommands.Count
}

function Test-PowerShellSyntax {
    param([string]$ScriptPath)

    $SyntaxErrors = @()

    try {
        if (Test-Path $ScriptPath) {
            $ScriptContent = Get-Content $ScriptPath -Raw
            # $ParseResult = [System.Management.Automation.PSParser]::Tokenize($ScriptContent, [ref]$null)

            # Check for common PowerShell syntax issues
            $Lines = $ScriptContent -split "`n"
            for ($i = 0; $i -lt $Lines.Count; $i++) {
                $Line = $Lines[$i]
                $LineNumber = $i + 1

                # Check for common syntax violations
                if ($Line -match '^\s*\$\w+\s*=\s*$') {
                    $SyntaxErrors += @{
                        Type = 'PowerShellSyntax'
                        Code = 'PS_INCOMPLETE_ASSIGNMENT'
                        Message = "Incomplete variable assignment on line $LineNumber"
                        File = $ScriptPath
                        LineNumber = $LineNumber
                        QuickFix = "Complete the variable assignment"
                    }
                }

                if ($Line -match '\$\(\s*$' -and -not ($Lines[$i+1] -match '^\s*\)')) {
                    $SyntaxErrors += @{
                        Type = 'PowerShellSyntax'
                        Code = 'PS_UNCLOSED_SUBEXPRESSION'
                        Message = "Unclosed subexpression on line $LineNumber"
                        File = $ScriptPath
                        LineNumber = $LineNumber
                        QuickFix = "Add closing parenthesis for subexpression"
                    }
                }

                if ($Line -match 'function\s+\w+\s*$' -and -not ($Lines[$i+1] -match '^\s*{')) {
                    $SyntaxErrors += @{
                        Type = 'PowerShellSyntax'
                        Code = 'PS_MISSING_FUNCTION_BODY'
                        Message = "Function missing opening brace on line $LineNumber"
                        File = $ScriptPath
                        LineNumber = $LineNumber
                        QuickFix = "Add opening brace for function body"
                    }
                }

                # Check for unmatched quotes
                $SingleQuotes = ($Line.ToCharArray() | Where-Object { $_ -eq "'" }).Count
                $DoubleQuotes = ($Line.ToCharArray() | Where-Object { $_ -eq '"' }).Count

                if ($SingleQuotes % 2 -ne 0 -or $DoubleQuotes % 2 -ne 0) {
                    $SyntaxErrors += @{
                        Type = 'PowerShellSyntax'
                        Code = 'PS_UNMATCHED_QUOTES'
                        Message = "Unmatched quotes on line $LineNumber"
                        File = $ScriptPath
                        LineNumber = $LineNumber
                        QuickFix = "Check quote matching and escaping"
                    }
                }
            }

            Write-LoadStatus "‚úÖ PowerShell syntax check complete: $($SyntaxErrors.Count) issues found" -Color $(if($SyntaxErrors.Count -gt 0){'Yellow'}else{'Green'})
        }
    }
    catch {
        $SyntaxErrors += @{
            Type = 'PowerShellSyntax'
            Code = 'PS_PARSE_ERROR'
            Message = "PowerShell parsing failed: $($_.Exception.Message)"
            File = $ScriptPath
            LineNumber = 0
            QuickFix = "Check overall script syntax and structure"
        }

        Write-LoadStatus "‚ùå PowerShell syntax check failed: $_" -Color 'Red'
    }

    return $SyntaxErrors
}

function Test-EnhancedErrorCapture {
    param(
        [switch]$RunBuildTest,
        [switch]$TestPowerShellSyntax,
        [switch]$TestProjectFiles
    )

    Write-LoadStatus "üß™ Testing Enhanced Error Capture System..." -Color 'Cyan'

    # Test PowerShell syntax if requested
    if ($TestPowerShellSyntax) {
        Write-LoadStatus "üîç Checking PowerShell script syntax..." -Color 'Yellow'

        $PSFiles = Get-ChildItem -Path $WorkspaceRoot -Filter "*.ps1" -Recurse | Select-Object -First 5
        $AllPSSyntaxErrors = @()

        foreach ($PSFile in $PSFiles) {
            $PSErrors = Test-PowerShellSyntax -ScriptPath $PSFile.FullName
            $AllPSSyntaxErrors += $PSErrors

            if ($PSErrors.Count -gt 0) {
                Write-LoadStatus "   ‚ö†Ô∏è $($PSFile.Name): $($PSErrors.Count) syntax issues" -Color 'Yellow'
                foreach ($PSError in $PSErrors) {
                    Write-LoadStatus "      ‚ùå Line $($PSError.LineNumber): $($PSError.Message)" -Color 'Red'
                    Write-LoadStatus "         üí° Fix: $($PSError.QuickFix)" -Color 'Cyan'
                }
            } else {
                Write-LoadStatus "   ‚úÖ $($PSFile.Name): No syntax issues" -Color 'Green'
            }
        }

        Write-LoadStatus "üìä PowerShell Syntax Summary: $($AllPSSyntaxErrors.Count) total issues across $($PSFiles.Count) files" -Color 'White'
    }

    # Test project files for common issues
    if ($TestProjectFiles) {
        Write-LoadStatus "üîç Checking project files for common issues..." -Color 'Yellow'

        $ProjectFiles = Get-ChildItem -Path $WorkspaceRoot -Filter "*.csproj" -Recurse
        foreach ($ProjectFile in $ProjectFiles) {
            $ProjectContent = Get-Content $ProjectFile.FullName -Raw

            # Check for common project file issues
            if ($ProjectContent -notmatch '<TargetFramework>') {
                Write-LoadStatus "   ‚ö†Ô∏è $($ProjectFile.Name): Missing TargetFramework specification" -Color 'Yellow'
            }

            if ($ProjectContent -match 'HintPath.*\.\.\\.*\\.*\\') {
                Write-LoadStatus "   ‚ö†Ô∏è $($ProjectFile.Name): Deep relative paths in references may cause issues" -Color 'Yellow'
            }

            if ($ProjectContent -match 'PackageReference.*Version="\*"') {
                Write-LoadStatus "   ‚ö†Ô∏è $($ProjectFile.Name): Wildcard package versions detected" -Color 'Yellow'
            }
        }
    }

    if ($RunBuildTest) {
        Write-LoadStatus "üî® Running build test with enhanced error capture..." -Color 'Yellow'

        $BuildResult = Invoke-BuildErrorCapture -ParseErrors -SuggestFixes

        Write-LoadStatus "üìä Build Results:" -Color 'White'
        Write-LoadStatus "   Exit Code: $($BuildResult.ExitCode)" -Color $(if($BuildResult.Success){'Green'}else{'Red'})
        Write-LoadStatus "   Success: $($BuildResult.Success)" -Color $(if($BuildResult.Success){'Green'}else{'Red'})

        if ($BuildResult.ParsedErrors) {
            $Errors = $BuildResult.ParsedErrors
            Write-LoadStatus "   Total Errors: $($Errors.TotalErrors)" -Color 'Red'
            Write-LoadStatus "   Total Warnings: $($Errors.TotalWarnings)" -Color 'Yellow'
            Write-LoadStatus "   Critical Issues: $($Errors.CriticalIssues.Count)" -Color 'Magenta'

            # Show ALL errors with enhanced categorization
            if ($Errors.TotalErrors -gt 0) {
                Write-LoadStatus "üîç Detailed Error Analysis by Type:" -Color 'Cyan'

                # Group errors by type for better organization
                $ErrorsByType = $Errors.Errors | Group-Object -Property Type

                foreach ($ErrorGroup in $ErrorsByType) {
                    Write-LoadStatus "üìÇ $($ErrorGroup.Name) Errors ($($ErrorGroup.Count)):" -Color 'White'

                    foreach ($errorItem in $ErrorGroup.Group) {
                        $ColorByType = switch ($errorItem.Type) {
                            'CompilationError' { 'Red' }
                            'XamlError' { 'Magenta' }
                            'SyncfusionError' { 'Blue' }
                            'PowerShellError' { 'Cyan' }
                            'MSBuildError' { 'DarkYellow' }
                            'NuGetError' { 'DarkGreen' }
                            'ResourceError' { 'DarkMagenta' }
                            default { 'Red' }
                        }

                        Write-LoadStatus "   ‚ùå $($errorItem.Code): $($errorItem.Message)" -Color $ColorByType
                        if ($errorItem.File -and $errorItem.File -ne "Unknown") {
                            Write-LoadStatus "      üìÅ File: $($errorItem.File)" -Color 'Gray'
                        }
                        Write-LoadStatus "      üí° Quick Fix: $($errorItem.QuickFix)" -Color 'Yellow'
                    }
                }
            }

            if ($Errors.HasCriticalIssues) {
                Write-LoadStatus "üö® Critical Issues Summary:" -Color 'Magenta'
                foreach ($Issue in $Errors.CriticalIssues) {
                    Write-LoadStatus "   üî• $($Issue.Code): Critical priority ($($Issue.Type))" -Color 'Magenta'
                }
            }

            # Show sample of warnings if any
            if ($Errors.TotalWarnings -gt 0) {
                Write-LoadStatus "‚ö†Ô∏è Warnings (first 3):" -Color 'Yellow'
                foreach ($Warning in $Errors.Warnings | Select-Object -First 3) {
                    Write-LoadStatus "   ‚ö†Ô∏è $($Warning.Code): $($Warning.Message)" -Color 'Yellow'
                }
                if ($Errors.TotalWarnings -gt 3) {
                    Write-LoadStatus "   ... and $($Errors.TotalWarnings - 3) more warnings" -Color 'Gray'
                }
            }
        }

        return $BuildResult
    }
    else {
        Write-LoadStatus "‚úÖ Enhanced error capture system loaded and ready" -Color 'Green'
        Write-LoadStatus "   Available options:" -Color 'Gray'
        Write-LoadStatus "   ‚Ä¢ Test-EnhancedErrorCapture -RunBuildTest" -Color 'Gray'
        Write-LoadStatus "   ‚Ä¢ Test-EnhancedErrorCapture -TestPowerShellSyntax" -Color 'Gray'
        Write-LoadStatus "   ‚Ä¢ Test-EnhancedErrorCapture -TestProjectFiles" -Color 'Gray'
        Write-LoadStatus "   ‚Ä¢ Test-EnhancedErrorCapture -RunBuildTest -TestPowerShellSyntax -TestProjectFiles" -Color 'Gray'
        return $true
    }
}

# Main execution
try {
    Write-LoadStatus "üöå Loading Bus Buddy PowerShell Environment..." -Color 'Cyan'
    Write-LoadStatus "   Workspace: $WorkspaceRoot" -Color 'Gray'

    # Validate PowerShell version
    Test-PowerShell752
    Write-LoadStatus "‚úÖ PowerShell 7.5.2+ detected: $($PSVersionTable.PSVersion)" -Color 'Green'

    # Validate paths
    if (-not (Test-Path $BusBuddyEnvironmentDir)) {
        throw "BusBuddy PowerShell Environment not found: $BusBuddyEnvironmentDir"
    }

    # Load main BusBuddy module (5,434 lines)
    $MainModuleLoaded = Import-BusBuddyModule -ModulePath $MainModulePath -ModuleName "BusBuddy Core Module (5,434 lines)" -ErrorAction SilentlyContinue

    # Load AI integration module if available
    if ((Test-Path $AIModulePath) -and (-not $SkipOptionalModules)) {
        if ($InstallMissingDependencies) {
            # Check and install missing dependencies
            $MissingDeps = Test-ModuleDependencies -ModulePath $AIModulePath
            if ($MissingDeps.Count -gt 0) {
                Write-LoadStatus "üì• Installing missing dependencies: $($MissingDeps -join ', ')" -Color 'Yellow'
                foreach ($Module in $MissingDeps) {
                    try {
                        Install-Module $Module -Scope CurrentUser -Force
                        Write-LoadStatus "‚úÖ Installed $Module" -Color 'Green'
                    }
                    catch {
                        Write-LoadStatus "‚ùå Failed to install $Module`: $_" -Color 'Red'
                    }
                }
            }
        }

        $AIModuleLoaded = Import-BusBuddyModule -ModulePath $AIModulePath -ModuleName "BusBuddy AI Integration"
    }
    elseif ($SkipOptionalModules) {
        Write-LoadStatus "‚è≠Ô∏è Skipping BusBuddy AI module (optional modules disabled)" -Color 'Gray'
        $AIModuleLoaded = $false
    }
    else {
        Write-LoadStatus "‚ö†Ô∏è BusBuddy AI module not found (optional)" -Color 'Yellow'
        $AIModuleLoaded = $false
    }

    # Test available commands
    $CommandCount = Test-BusBuddyCommands

    # Test enhanced error capture system
    Test-EnhancedErrorCapture

    # Summary
    Write-LoadStatus ""
    Write-LoadStatus "üéâ Bus Buddy Profile Loading Complete!" -Color 'Green'
    Write-LoadStatus "   Main Module: $(if($MainModuleLoaded){'‚úÖ Loaded'}else{'‚ùå Failed'})" -Color $(if($MainModuleLoaded){'Green'}else{'Red'})
    Write-LoadStatus "   AI Module: $(if($AIModuleLoaded){'‚úÖ Loaded'}else{'‚ö†Ô∏è Not Available'})" -Color $(if($AIModuleLoaded){'Green'}else{'Yellow'})
    Write-LoadStatus "   Commands Available: $CommandCount" -Color 'Cyan'
    Write-LoadStatus "   Enhanced Error Capture: ‚úÖ Ready" -Color 'Green'
    Write-LoadStatus ""

    if ($CommandCount -gt 0) {
        Write-LoadStatus "üöÄ Ready for BusBuddy development!" -Color 'Green'
        Write-LoadStatus "   Try: bb-health, bb-dev-session, or Test-EnhancedErrorCapture -RunBuildTest" -Color 'Yellow'
    }
    else {
        Write-LoadStatus "‚ö†Ô∏è No BusBuddy commands available. Check module loading." -Color 'Yellow'
    }
}
catch {
    Write-LoadStatus "‚ùå Profile loading failed: $_" -Color 'Red'
    Write-LoadStatus "   Location: $($_.InvocationInfo.ScriptName):$($_.InvocationInfo.ScriptLineNumber)" -Color 'Gray'
    exit 1
}
